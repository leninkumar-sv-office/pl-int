"""
Zerodha Kite Connect service — primary price source.

Uses Kite Connect v3 REST API directly (no SDK dependency).
Provides stock quotes, market indices, and instrument search.

Auth flow:
  1. User visits login URL (generated by get_login_url())
  2. Kite redirects with ?request_token=... to our callback
  3. We exchange request_token → access_token via generate_session()
  4. access_token is stored in .env / memory for subsequent calls

All API calls need: api_key + access_token (daily refresh required).
"""
import os
import json
import time
import hashlib
import threading
import requests
from typing import Optional, Dict, List, Tuple
from dotenv import load_dotenv

# ═══════════════════════════════════════════════════════════
#  CONFIG
# ═══════════════════════════════════════════════════════════

_ENV_PATH = os.path.join(os.path.dirname(__file__), "..", ".env")
load_dotenv(_ENV_PATH)

_BASE_URL = "https://api.kite.trade"
_LOGIN_URL = "https://kite.zerodha.com/connect/login"
_API_VERSION = "3"

_api_key: str = os.getenv("ZERODHA_API_KEY", "").strip()
_api_secret: str = os.getenv("ZERODHA_API_SECRET", "").strip()
_access_token: str = os.getenv("ZERODHA_ACCESS_TOKEN", "").strip()

# Log what we loaded (masked)
if _api_key:
    print(f"[Zerodha] API key loaded: {_api_key[:4]}...{_api_key[-4:]} ({len(_api_key)} chars)")
if _access_token:
    print(f"[Zerodha] Access token loaded: {_access_token[:4]}...{_access_token[-4:]} ({len(_access_token)} chars)")

# Thread safety
_lock = threading.Lock()
_session_valid = False
_last_error = ""
_auth_failed = False  # Set True on 403 — stops retrying until token is refreshed
_conn_failed = False  # Set True on connection errors — retries once per refresh cycle
_conn_fail_time = 0.0  # When connection last failed (retry after 60s)

# Instrument cache: {exchange:tradingsymbol → instrument_token}
_instrument_cache: Dict[str, int] = {}
_instruments_loaded = False

# Instrument name cache: {"SYMBOL.EXCHANGE" → "Company Name"}
_instrument_names: Dict[str, str] = {}
_instrument_names_loaded = False
_instrument_names_lock = threading.Lock()


def _headers() -> dict:
    """Build auth headers for Kite API."""
    return {
        "X-Kite-Version": _API_VERSION,
        "Authorization": f"token {_api_key}:{_access_token}",
    }


def _api_get(path: str, params: dict = None) -> Optional[dict]:
    """Make authenticated GET request to Kite API."""
    global _auth_failed, _last_error, _conn_failed, _conn_fail_time
    if not _api_key or not _access_token:
        return None
    if _auth_failed:
        return None  # Don't keep retrying after 403
    # Skip if connection recently failed (retry after 60s)
    if _conn_failed and (time.time() - _conn_fail_time) < 60:
        return None
    try:
        resp = requests.get(
            f"{_BASE_URL}{path}",
            headers=_headers(),
            params=params,
            timeout=(5, 10),  # (connect_timeout, read_timeout)
        )
        # Connection succeeded — reset conn_failed
        _conn_failed = False
        if resp.status_code == 200:
            _auth_failed = False  # Reset on success
            return resp.json()
        elif resp.status_code == 403:
            _auth_failed = True
            _last_error = f"Auth failed (403): {resp.text[:200]}"
            print(f"[Zerodha] {_last_error}")
            print(f"[Zerodha] Token expired. Visit http://localhost:8000/api/zerodha/login to refresh.")
            with _lock:
                global _session_valid
                _session_valid = False
            return None
        else:
            _last_error = f"API error {resp.status_code}: {resp.text[:100]}"
            print(f"[Zerodha] {_last_error}")
            return None
    except requests.exceptions.RequestException as e:
        _conn_failed = True
        _conn_fail_time = time.time()
        _last_error = f"Connection failed: {str(e)[:120]}"
        print(f"[Zerodha] Request failed: {e}")
        return None


# ═══════════════════════════════════════════════════════════
#  AUTH
# ═══════════════════════════════════════════════════════════

def is_configured() -> bool:
    """Check if Zerodha API key is configured."""
    return bool(_api_key)


def is_session_valid() -> bool:
    """Check if we have a valid access token (and it hasn't been rejected)."""
    return bool(_api_key and _access_token and not _auth_failed)


def get_login_url(redirect_url: str = "http://localhost:8000/api/zerodha/callback") -> str:
    """Get Kite login URL for user to authenticate."""
    return f"{_LOGIN_URL}?v={_API_VERSION}&api_key={_api_key}&redirect_url={redirect_url}"


def generate_session(request_token: str) -> bool:
    """Exchange request_token for access_token using API secret.
    Call this after user completes Kite login."""
    global _access_token, _session_valid, _auth_failed, _conn_failed
    if not _api_key or not _api_secret:
        print("[Zerodha] API key or secret not configured")
        return False

    # Checksum: SHA-256 of (api_key + request_token + api_secret)
    checksum = hashlib.sha256(
        f"{_api_key}{request_token}{_api_secret}".encode()
    ).hexdigest()

    try:
        resp = requests.post(
            f"{_BASE_URL}/session/token",
            data={
                "api_key": _api_key,
                "request_token": request_token,
                "checksum": checksum,
            },
            timeout=10,
        )
        if resp.status_code == 200:
            data = resp.json().get("data", {})
            _access_token = data.get("access_token", "")
            if _access_token:
                # Reset all failure flags — we have a fresh valid token
                _auth_failed = False
                _conn_failed = False
                with _lock:
                    _session_valid = True
                # Persist to .env
                _update_env("ZERODHA_ACCESS_TOKEN", _access_token)
                print(f"[Zerodha] Session created, token: {_access_token[:8]}...")
                return True
        print(f"[Zerodha] Session failed: {resp.status_code} {resp.text[:200]}")
    except Exception as e:
        print(f"[Zerodha] Session error: {e}")
    return False


def set_access_token(token: str):
    """Manually set access token (e.g. from frontend)."""
    global _access_token, _session_valid, _auth_failed, _conn_failed
    _access_token = token.strip()
    _auth_failed = False  # Reset — allow retrying with new token
    _conn_failed = False  # Reset connection failure too
    with _lock:
        _session_valid = bool(_access_token)
    if _access_token:
        _update_env("ZERODHA_ACCESS_TOKEN", _access_token)
        print(f"[Zerodha] Access token set: {_access_token[:8]}...")


def _update_env(key: str, value: str):
    """Update a key in the .env file."""
    try:
        lines = []
        found = False
        if os.path.exists(_ENV_PATH):
            with open(_ENV_PATH) as f:
                for line in f:
                    if line.strip().startswith(f"{key}="):
                        lines.append(f"{key}={value}\n")
                        found = True
                    else:
                        lines.append(line)
        if not found:
            lines.append(f"{key}={value}\n")
        with open(_ENV_PATH, "w") as f:
            f.writelines(lines)
    except Exception as e:
        print(f"[Zerodha] Failed to update .env: {e}")


# ═══════════════════════════════════════════════════════════
#  STOCK QUOTES
# ═══════════════════════════════════════════════════════════

# ── Symbol mapping: xlsx symbol → correct Kite trading symbol ──
# Some stocks have different trading symbols on exchanges than what's
# stored in our xlsx files (due to name changes, demergers, IPO symbols, etc.)
_KITE_SYMBOL_MAP: Dict[str, str] = {
    # BSE symbol truncated (BSE uses max 10 chars)
    "HIGHENERGY.BSE": "BSE:HIGHENE",
    # Historical file still named "Majesco Ltd.xlsx" but company renamed to Aurum
    "MAJESCO.NSE": "NSE:AURUM",
}


def _kite_instrument(symbol: str, exchange: str) -> str:
    """Convert symbol + exchange to Kite instrument key.
    Checks the override map first, then falls back to EXCHANGE:SYMBOL.
    e.g. ('RELIANCE', 'NSE') → 'NSE:RELIANCE'
         ('MAJESCO', 'NSE') → 'NSE:AURUM' (from override map)
    """
    sym = symbol.upper()
    exch = exchange.upper()
    if exch not in ("BSE", "NSE"):
        exch = "NSE"

    # Check override map
    lookup_key = f"{sym}.{exch}"
    if lookup_key in _KITE_SYMBOL_MAP:
        return _KITE_SYMBOL_MAP[lookup_key]

    return f"{exch}:{sym}"


def fetch_ltp(symbols: List[Tuple[str, str]]) -> Dict[str, float]:
    """Fetch Last Traded Price for multiple instruments.
    Returns {symbol.exchange: price}."""
    if not is_session_valid():
        return {}

    # Build instrument list: i=NSE:RELIANCE&i=BSE:TCS
    # Use list of keys (not single) to handle multiple symbols → same Kite instrument
    seen_instruments = set()
    instruments = []
    inst_to_keys: Dict[str, List[str]] = {}  # kite_inst → [sym.exch, ...]
    for sym, exch in symbols:
        inst = _kite_instrument(sym, exch)
        key = f"{sym}.{exch}"
        inst_to_keys.setdefault(inst, []).append(key)
        if inst not in seen_instruments:
            instruments.append(inst)
            seen_instruments.add(inst)

    # Kite allows up to 500 instruments per LTP call
    results: Dict[str, float] = {}
    batch_size = 500
    for i in range(0, len(instruments), batch_size):
        batch = instruments[i:i + batch_size]
        params = [("i", inst) for inst in batch]
        data = _api_get("/quote/ltp", params)
        if data and "data" in data:
            for inst_key, info in data["data"].items():
                mapped_keys = inst_to_keys.get(inst_key, [])
                if mapped_keys and info.get("last_price", 0) > 0:
                    price = float(info["last_price"])
                    for mk in mapped_keys:
                        results[mk] = price

    return results


def fetch_quotes(symbols: List[Tuple[str, str]]) -> Dict[str, dict]:
    """Fetch full quotes (price, OHLC, volume, 52wk range) for multiple instruments.
    Returns {symbol.exchange: {price, open, high, low, close, volume, ...}}."""
    if not is_session_valid():
        return {}

    seen_instruments = set()
    instruments = []
    inst_to_keys: Dict[str, List[str]] = {}
    for sym, exch in symbols:
        inst = _kite_instrument(sym, exch)
        key = f"{sym}.{exch}"
        inst_to_keys.setdefault(inst, []).append(key)
        if inst not in seen_instruments:
            instruments.append(inst)
            seen_instruments.add(inst)

    results: Dict[str, dict] = {}
    batch_size = 500
    for i in range(0, len(instruments), batch_size):
        batch = instruments[i:i + batch_size]
        params = [("i", inst) for inst in batch]
        data = _api_get("/quote", params)
        if data and "data" in data:
            for inst_key, info in data["data"].items():
                mapped_keys = inst_to_keys.get(inst_key, [])
                if not mapped_keys:
                    continue
                ltp = float(info.get("last_price", 0))
                if ltp <= 0:
                    continue

                ohlc = info.get("ohlc", {})
                prev_close = float(ohlc.get("close", 0))
                day_change = ltp - prev_close if prev_close > 0 else 0
                day_change_pct = (day_change / prev_close * 100) if prev_close > 0 else 0

                quote_data = {
                    "price": round(ltp, 2),
                    "open": float(ohlc.get("open", 0)),
                    "high": float(ohlc.get("high", 0)),
                    "low": float(ohlc.get("low", 0)),
                    "close": prev_close,
                    "volume": int(info.get("volume", 0) or 0),
                    "day_change": round(day_change, 2),
                    "day_change_pct": round(day_change_pct, 2),
                    "lower_circuit": float(info.get("lower_circuit_limit", 0) or 0),
                    "upper_circuit": float(info.get("upper_circuit_limit", 0) or 0),
                    "week_52_high": float(info.get("ohlc", {}).get("high", 0) or 0),
                    "week_52_low": float(info.get("ohlc", {}).get("low", 0) or 0),
                    "name": "",  # Kite doesn't return company name in quotes
                }
                for mk in mapped_keys:
                    results[mk] = quote_data

    return results


def fetch_ohlc(symbols: List[Tuple[str, str]]) -> Dict[str, dict]:
    """Fetch OHLC + LTP for multiple instruments (lighter than full quote).
    Returns {symbol.exchange: {price, open, high, low, close, volume}}."""
    if not is_session_valid():
        return {}

    seen_instruments = set()
    instruments = []
    inst_to_keys: Dict[str, List[str]] = {}
    for sym, exch in symbols:
        inst = _kite_instrument(sym, exch)
        key = f"{sym}.{exch}"
        inst_to_keys.setdefault(inst, []).append(key)
        if inst not in seen_instruments:
            instruments.append(inst)
            seen_instruments.add(inst)

    results: Dict[str, dict] = {}
    batch_size = 500
    for i in range(0, len(instruments), batch_size):
        batch = instruments[i:i + batch_size]
        params = [("i", inst) for inst in batch]
        data = _api_get("/quote/ohlc", params)
        if data and "data" in data:
            for inst_key, info in data["data"].items():
                mapped_keys = inst_to_keys.get(inst_key, [])
                if not mapped_keys:
                    continue
                ltp = float(info.get("last_price", 0))
                if ltp <= 0:
                    continue
                ohlc = info.get("ohlc", {})
                ohlc_data = {
                    "price": round(ltp, 2),
                    "open": float(ohlc.get("open", 0)),
                    "high": float(ohlc.get("high", 0)),
                    "low": float(ohlc.get("low", 0)),
                    "close": float(ohlc.get("close", 0)),
                    "volume": 0,  # Not in OHLC response
                }
                for mk in mapped_keys:
                    results[mk] = ohlc_data

    return results


# ═══════════════════════════════════════════════════════════
#  MARKET TICKERS (Indices, Forex, Commodities)
# ═══════════════════════════════════════════════════════════


def _get_near_month_suffixes() -> List[str]:
    """Get YY+MMM suffixes for current month, next month, and month after.
    e.g. ['26FEB', '26MAR', '26APR'] for Feb 2026."""
    from datetime import datetime, timedelta
    now = datetime.now()
    suffixes = []
    for offset_months in range(3):
        dt = now.replace(day=1)
        for _ in range(offset_months):
            dt = (dt + timedelta(days=32)).replace(day=1)
        suffixes.append(f"{dt.strftime('%y')}{dt.strftime('%b').upper()}")
    return suffixes


def _build_ticker_candidates() -> Dict[str, List[str]]:
    """Build candidate Kite instruments for each market ticker key.
    Tries current month, next month for futures contracts.
    Returns {ticker_key: [candidate1, candidate2, ...]}"""
    suffixes = _get_near_month_suffixes()
    s0, s1, s2 = suffixes[0], suffixes[1], suffixes[2]

    return {
        # Indices — fixed names, always available
        "SENSEX":   ["BSE:SENSEX"],
        "NIFTY50":  ["NSE:NIFTY 50"],

        # Currency derivatives (CDS segment on NSE)
        "USDINR":   [f"CDS:USDINR{s0}FUT", f"CDS:USDINR{s1}FUT"],

        # MCX Commodities — near-month futures
        # Crude Oil: monthly contracts
        "CRUDEOIL": [f"MCX:CRUDEOIL{s0}FUT", f"MCX:CRUDEOIL{s1}FUT",
                     f"MCX:CRUDEOILM{s0}FUT", f"MCX:CRUDEOILM{s1}FUT"],
        # Gold: bi-monthly (Feb, Apr, Jun, Aug, Oct, Dec) + Gold Mini (monthly)
        "GOLD":     [f"MCX:GOLD{s0}FUT", f"MCX:GOLD{s1}FUT", f"MCX:GOLD{s2}FUT",
                     f"MCX:GOLDM{s0}FUT", f"MCX:GOLDM{s1}FUT",
                     f"MCX:GOLDPETAL{s0}FUT", f"MCX:GOLDPETAL{s1}FUT"],
        # Silver: monthly + Silver Mini
        "SILVER":   [f"MCX:SILVER{s0}FUT", f"MCX:SILVER{s1}FUT",
                     f"MCX:SILVERM{s0}FUT", f"MCX:SILVERM{s1}FUT",
                     f"MCX:SILVERMIC{s0}FUT", f"MCX:SILVERMIC{s1}FUT"],

        # International — not available on Indian exchanges via Kite
        "SGX":      [],
        "NIKKEI":   [],
        "SGDINR":   [],
    }


def fetch_market_tickers() -> Dict[str, dict]:
    """Fetch market ticker data from Kite (indices + forex + MCX commodities).
    Uses dynamic near-month contract names for futures.
    Returns {key: {price, change, change_pct}} for available instruments."""
    if not is_session_valid():
        return {}

    candidates = _build_ticker_candidates()

    # Collect ALL candidate instruments into a single API call
    all_instruments = []
    inst_to_ticker: Dict[str, str] = {}  # kite_inst → ticker_key
    inst_priority: Dict[str, int] = {}   # kite_inst → priority (lower = better)
    for ticker_key, cands in candidates.items():
        for idx, kite_inst in enumerate(cands):
            all_instruments.append(kite_inst)
            inst_to_ticker[kite_inst] = ticker_key
            inst_priority[kite_inst] = idx

    if not all_instruments:
        return {}

    # One API call with all candidates
    params = [("i", inst) for inst in all_instruments]
    data = _api_get("/quote", params)
    if not data or "data" not in data:
        return {}

    # Parse responses, pick best candidate per ticker (lowest priority index)
    ticker_results: Dict[str, Tuple[int, dict]] = {}  # key → (priority, data)
    for inst_key, info in data["data"].items():
        ticker_key = inst_to_ticker.get(inst_key, "")
        if not ticker_key:
            continue
        ltp = float(info.get("last_price", 0))
        if ltp <= 0:
            continue
        priority = inst_priority.get(inst_key, 999)

        # Only keep the highest-priority (lowest idx) result per ticker
        existing = ticker_results.get(ticker_key)
        if existing and existing[0] <= priority:
            continue

        ohlc = info.get("ohlc", {})
        prev_close = float(ohlc.get("close", 0))
        change = ltp - prev_close if prev_close > 0 else 0
        pct = (change / prev_close * 100) if prev_close > 0 else 0
        ticker_results[ticker_key] = (priority, {
            "price": round(ltp, 2),
            "change": round(change, 2),
            "change_pct": round(pct, 2),
            "instrument": inst_key,  # Track which Kite instrument matched
        })

    # Flatten: drop priority, keep just the data
    results: Dict[str, dict] = {}
    for key, (_, ticker_data) in ticker_results.items():
        results[key] = ticker_data
        print(f"[Zerodha] Ticker {key} → {ticker_data['instrument']} "
              f"({ticker_data['price']})")

    return results


# ═══════════════════════════════════════════════════════════
#  INSTRUMENT NAME LOOKUP
# ═══════════════════════════════════════════════════════════

def _load_instruments():
    """Download instrument CSVs from Kite (NSE + BSE equity) and cache names.
    The /instruments/{exchange} endpoint returns a CSV with columns:
    instrument_token,exchange_token,tradingsymbol,name,last_price,expiry,
    strike,tick_size,lot_size,instrument_type,segment,exchange
    """
    global _instrument_names_loaded
    import csv
    import io

    if not _api_key or not _access_token:
        return

    with _instrument_names_lock:
        if _instrument_names_loaded:
            return

    names: Dict[str, str] = {}
    for exchange in ("NSE", "BSE"):
        try:
            resp = requests.get(
                f"{_BASE_URL}/instruments/{exchange}",
                headers=_headers(),
                timeout=(5, 30),
            )
            if resp.status_code != 200:
                print(f"[Zerodha] Instruments {exchange} failed: {resp.status_code}")
                continue
            reader = csv.DictReader(io.StringIO(resp.text))
            count = 0
            for row in reader:
                segment = row.get("segment", "")
                # Only equity instruments (skip F&O, CDS, etc.)
                if segment not in (f"{exchange}", f"{exchange}-EQ"):
                    continue
                sym = row.get("tradingsymbol", "").strip()
                name = row.get("name", "").strip()
                if sym and name:
                    names[f"{sym}.{exchange}"] = name
                    count += 1
            print(f"[Zerodha] Loaded {count} {exchange} instrument names")
        except Exception as e:
            print(f"[Zerodha] Instruments {exchange} error: {e}")

    with _instrument_names_lock:
        _instrument_names.update(names)
        _instrument_names_loaded = True
    print(f"[Zerodha] Total instrument names cached: {len(_instrument_names)}")


def load_instruments_async():
    """Load instruments in a background thread (call at startup)."""
    t = threading.Thread(target=_load_instruments, daemon=True)
    t.start()


def lookup_instrument_name(symbol: str, exchange: str = "NSE") -> str:
    """Look up company name for a symbol from cached instruments.
    Returns empty string if not found."""
    if not _instrument_names_loaded:
        _load_instruments()  # Blocking load on first call if not yet loaded
    key = f"{symbol.upper()}.{exchange.upper()}"
    return _instrument_names.get(key, "")


def search_instruments(query: str, exchange: str = "") -> list:
    """Search instruments by symbol or name prefix.
    Returns up to 10 matches: [{symbol, name, exchange}]."""
    if not _instrument_names_loaded:
        _load_instruments()
    q = query.upper().strip()
    if not q:
        return []
    results = []
    for key, name in _instrument_names.items():
        sym, exch = key.rsplit(".", 1)
        if exchange and exch != exchange.upper():
            continue
        if sym.startswith(q) or q in name.upper():
            results.append({"symbol": sym, "name": name, "exchange": exch})
            if len(results) >= 10:
                break
    # Sort: exact prefix matches first, then alphabetical
    results.sort(key=lambda r: (0 if r["symbol"].startswith(q) else 1, r["symbol"]))
    return results


# ═══════════════════════════════════════════════════════════
#  STATUS
# ═══════════════════════════════════════════════════════════

def get_status() -> dict:
    """Get current Zerodha connection status."""
    return {
        "configured": is_configured(),
        "has_api_secret": bool(_api_secret),
        "has_access_token": bool(_access_token),
        "session_valid": is_session_valid(),
        "auth_failed": _auth_failed,
        "api_key_prefix": _api_key[:4] + "..." if _api_key else "",
        "token_prefix": _access_token[:4] + "..." if _access_token else "",
        "last_error": _last_error,
    }


def validate_session() -> bool:
    """Test if current access token works by hitting /user/profile."""
    if not is_session_valid():
        return False
    data = _api_get("/user/profile")
    if data and "data" in data:
        user = data["data"]
        name = user.get("user_name", "Unknown")
        print(f"[Zerodha] Session valid — user: {name}")
        with _lock:
            global _session_valid
            _session_valid = True
        return True
    with _lock:
        _session_valid = False
    return False
